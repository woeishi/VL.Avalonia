using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace VL.Avalonia.CodeGen.ClassHandlers;

/// <summary>
/// TODO convert to Class
/// </summary>
public class ProcessNodeHandler : IClassHandler
{
    public bool CanHandle(ClassDeclarationSyntax classDecl) =>
        classDecl.AttributeLists.Any(attrs =>
            attrs.Attributes.Any(a =>
                a.Name.NormalizeWhitespace().ToFullString().StartsWith("ProcessNode")));

    public string? GenerateClass(ClassDeclarationSyntax classDecl,
    ISymbol classSymbol,
    IEnumerable<string> generatedMethods)
    {
        var sb = new StringBuilder();

        // Extract usings from the syntax tree
        foreach (var usingStatement in classDecl.SyntaxTree.GetCompilationUnitRoot().Usings)
        {
            sb.AppendLine(usingStatement.ToString());
        }

        var usingSection = sb.ToString().Trim();

        // 2. Namespace logic
        var nameSpace = classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

        // 3. Modifiers (ensure partial)
        var modifiers = string.Join(" ", classDecl.Modifiers
            .Where(m => m.Text == "public" || m.Text == "internal" || m.Text == "partial"));
        if (!modifiers.Contains("partial"))
            modifiers += " partial";
        modifiers = modifiers.Trim();

        // 4. Class attributes
        //var attributes = classDecl.AttributeLists.Select(a => a.ToFullString().Trim())

        var attributes = "";

        // 5. Class name with generic parameters
        var className = classDecl.Identifier.Text + classDecl.TypeParameterList?.ToFullString();



        var template =
$@"// <auto-generated/>
{usingSection}

namespace {nameSpace};

{attributes}
{modifiers} class {className}
{{
    {string.Join("\n", generatedMethods)}
}}
";
        return template;
    }
}

